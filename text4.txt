docker compose exec api python manage.py shell
###############################
import django
django.apps.apps.app_configs.keys()

dict_keys(['admin', 'auth', 'contenttypes', 'sessions', 'messages', 'staticfiles', 'rest_framework', 'market', 'corsheaders', 'authtoken'])
 


 thyats the name of my api market 
###############################

to check the real django path:
1.import sys
sys.path

2.import django
django.apps.apps.get_app_config('market').name

3.from apps.market.models import Store, Category, Product, Sale, SaleItem

Store.objects.all()
Category.objects.all()
Product.objects.all()


to add thing on it :

Store.objects.all()
store = Store.objects.first()

Category.objects.create(name="Electronics", store=store)
Category.objects.create(name="Accessories", store=store)
Category.objects.create(name="Office", store=store)

Category.objects.all()

cat = Category.objects.get(name="Electronics")

Product.objects.create(
    name="Laptop Lenovo",
    store=store,
    category=cat,
    price=2500000,
    stock_quantity=10
)

Product.objects.create(
    name="Monitor Samsung",
    store=store,
    category=cat,
    price=900000,
    stock_quantity=7
)


Product.objects.all()
###############################


Very important portfolio-level next step (recommended)
Right now you are inserting manually, but real backend systems do:


seed_database.py
fixtures.json
POST /api/categories/
POST /api/products/


###############################

from django.contrib.auth.models import User
from apps.market.models import Store, Category, Product

user = User.objects.create_user(
    username="leon1186",
    password="leon1186"
)

store = Store.objects.create(
    name="Mini Market Central",
    owner=user
)



beverages = Category.objects.create(
    store=store,
    name="Beverages"
)

snacks = Category.objects.create(
    store="Mini Market EC2",
    name="Snacks"
)




Product.objects.create(
    store=store,
    category=beverages,
    name="Coca Cola 1L",
    price=4000,
    stock_quantity=50
)

Product.objects.create(
    store=store,
    category=snacks,
    name="Doritos",
    price=3500,
    stock_quantity=30
)


docker compose exec db psql -U postgres -d market
http://localhost:8000/api/products/

docker compose exec api python manage.py createsuperuser
docker compose exec db psql -U postgres -d market
SELECT id, username, is_superuser FROM auth_user;

#########################################

Database
   â†“
Django Auth
   â†“
Django REST Framework
   â†“
Token Authentication
   â†“
Frontend

#########################################
ðŸ”¥ Important: They Are NOT Competing

You can use:

Admin for internal management

Token for frontend

Auth as foundation
    
They work together.

#########################################



âš  Important Difference
POST	PUT
Creates	Updates
No ID in URL	ID required in URL
Generates new record	Modifies existing record
Multiple calls create duplicates	Multiple calls overwrite same record


#########################################


#########################################
ðŸ§  Backend Concept Level

Under the hood:

Your ModelViewSet automatically provides:

create() â†’ POST

update() â†’ PUT

partial_update() â†’ PATCH

destroy() â†’ DELETE

list() â†’ GET

retrieve() â†’ GET by ID

Thatâ€™s why DRF is powerful.





Internet
   â†“
Port 80  â†’ frontend container (nginx)
Port 8000 â†’ api container (gunicorn)
Port 5432 â†’ db container (internal only)
