docker compose exec api python manage.py shell

from django.contrib.auth.models import User
from apps.market.models import Store, Category, Product

user = User.objects.create_user(
    username="owner1",
    password="1234"
)

store = Store.objects.create(
    name="Mini Market Central",
    owner=user
)



beverages = Category.objects.create(
    store=store,
    name="Beverages"
)

snacks = Category.objects.create(
    store=store,
    name="Snacks"
)




Product.objects.create(
    store=store,
    category=beverages,
    name="Coca Cola 1L",
    price=4000,
    stock_quantity=50
)

Product.objects.create(
    store=store,
    category=snacks,
    name="Doritos",
    price=3500,
    stock_quantity=30
)



http://localhost:8000/api/products/

docker compose exec api python manage.py createsuperuser
docker compose exec db psql -U postgres -d market
SELECT id, username, is_superuser FROM auth_user;

#########################################

Database
   â†“
Django Auth
   â†“
Django REST Framework
   â†“
Token Authentication
   â†“
Frontend

#########################################
ðŸ”¥ Important: They Are NOT Competing

You can use:

Admin for internal management

Token for frontend

Auth as foundation
    
They work together.

#########################################



âš  Important Difference
POST	PUT
Creates	Updates
No ID in URL	ID required in URL
Generates new record	Modifies existing record
Multiple calls create duplicates	Multiple calls overwrite same record


#########################################


#########################################
ðŸ§  Backend Concept Level

Under the hood:

Your ModelViewSet automatically provides:

create() â†’ POST

update() â†’ PUT

partial_update() â†’ PATCH

destroy() â†’ DELETE

list() â†’ GET

retrieve() â†’ GET by ID

Thatâ€™s why DRF is powerful.